#### 目标
1. 什么是线程，创建方式、线程状态  
2. 消费者和生产者模型  
3. 同步和锁  
4. 什么是主线程和子线程  
5. 线程池  
6. Java 线程安全的集合、队列、Map  

#### 计划完成时间 一个月  

### 什么是线程？ 线程的创建方式  
1. 线程是OS进行运算调度的最小单元。线程是被包含在进程内，一个进程内的多个线程共享进程资源。

2. 线程的创建方式  
在Java中 单独创建线程都需要使用类 java.lang.Thread。  
2.1 通过继承自Thread类并覆写run()方法  
2.2 实现一个Runnable接口，并在创建线程的时候讲Runnable接口的实例传入。  
```java
//继承自Thread实现run()方法  
class MyThread extends Thread{
  @Override
  public void run(){
    //do something
  }
}

//实现Runnable接口，并实例化传入线程对象中  
class MyRunnable implement Runnable{
  @Override
  public void run(){
    //do something
  }
}
Thread thread = new Thread(new MyRunnable());  
```
以上只是创建了一个线程，真正让一个线程跑起来，能够被OS调度执行 ，还需要调用 `Thread.start()`方法。 这个方法会调用本地方法JNI 来实现一个真正意义上的线程，或者说只有start()  
成功调用后由OS分配线程资源，才能叫做线程。 而在JVM中分配的Thread对象只是与之对应的外壳。  

* 注: 
1. Runnable和Thread的关系 可以理解为  Runnable是任务， Thread是执行任务的，至于执行什么样的任务，Thread不管，开发者通过实现Runnable接口并根据业务逻辑覆写run()方法  
然后将任务交由Thread执行。这样就解耦了任务和线程。都只需要关注各自的事情。  
2. Thread本身所对应的实例仅是JVM内的一个普通java对象，是一个线程操作的外壳，而不是真正的线程.  

# 

### 线程的几种状态    
1. 对线程的每个操作，都可能会是线程处于不同的工作机制下，在不同的工作机制下某些动作可能会产生不同的影响，而不同的工作机制就是用状态来标志的，同时不同状态之间可以相互转换。

2. Java线程的状态一共有六种。    
 * 什么情况会转换到这个状态？    
 * 在这个状态下会有什么情况？    

#### NEW:   
表明 这个线程刚被start()启动，从本质上来讲只是创建了Java外壳，还没有真正的线程来运行   

#### RUNNABLE:    
这个状态表明存活着正在征用CPU的线程(有可能这个瞬间并没有被CPU选中，但是它可能正在发送指令等待系统调度)，由于在真正的系统中，并不是开启一个线程后 CPU就只为这一个线程
服务，它必须使用许多调度算法来达到某种平衡，不过这个时候线程依然处于RUNNABLE状态  
这个状态可以由WAIT、TIME_WAIT、BLOCKED通过 notify、notifyAll、获得锁等方式进入该状态。当然处于该状态也会可以执行许多操作进入到其他状态 (参见线程状态图)。
* 注意: 一个线程在Java层面可能是RUNNABLE状态，但这并不代表着这个线程就处于运行中。比如 线程正阻塞在网络等待时，看到的状态依然是RUNNABLE状态，而在底层线程已经被阻塞。     

#### WAIT   
1. 这个状态表明一个线程获得锁后 进入相应的代码执行区，调用了“对象”的wait()方法操作后产生的一种后果。出现这种调用一般是当线程在执行某个动作时由于条件不满足，所以暂时先退出执行区域，    
   等待条件满足再来。最典型的例子通过wait()、notify()或notifyAll()完成消费者-生产者模型，当"消费者"线程 消费过快时，仓库已经没有资源了，这个时候应该让消费者线程暂停执行，只有等到    
   仓库有资源了(`条件满足`)，这时唤醒"沉睡"的消费者线程，再次消费。     
   同样的如果"生产者"线程 生产资源够多，仓库"爆仓"了，这个时候生产者线程也应该停止再生产，等待资源被消耗后 这时再"唤醒"生产者线程，再次继续生产。这里体现是通过制衡方式的协调工作机制。  
   在这种状态下，如果发生了对该线程的interrupt()是有用的，处于该状态的线程内部会抛出一个InterruptedException异常，这个异常应当在run()方法里面再次捕获，使得run()方法正常的执行。  
2. 调用某个对象的wait()方法后，首先线程会让出锁资源，同时线程会"沉睡"，不会被CPU再调度，除非有人"唤醒" (调用对象的notify()或notifyAll()方法)它。  

#### TIME_WAIT    
这个状态和上面类似也是进入了等待状态，不过这个是有时间限制的，一旦超过这个时间，线程会自动被"唤醒" 。Thread.sleep(long),Thread.join(long)都可以使线程进入TIME_WAIT状态。  
* 注意: Thread.sleep(long) 如果是在同步区调用的，那么这个线程在"沉睡"期间不会释放锁，及时它没有运行。所有等待同一把锁执行的线程只能干等着。  

#### BLOCKED  
1. 当多个线程竞争同一把"锁",没有被竞争到的线程就会处于阻塞状态，在这个状态下 线程就相当于"沉睡"了，只有当持有"锁"的线程执行完synchronize区域的代码后，退出归还锁，这样才有机会再次去争夺    
进入临界区的权利。争取到锁后会从BLOCKED状态恢复到RUNNABLE状态，如果在征用"锁"的过程中失败了，那么它又只能回休息室等待去了。  
2. 一旦线程处于BLOCKED状态，线程就项什么都不做一样，在JAVA层面始终无法唤醒它，通过interrupt()方法来唤醒也一样。所以在synchronized时通常要考虑它的粒度问题，更要考虑它是否可能会死锁的问题。  

#### TERMINAED  
线程结束了就处于这样一种状态，换句话说就是run()方法走完了，线程就处于这种状态。    

![线程状态图]
{https://img-blog.csdnimg.cn/20181120173640764.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BhbmdlMTk5MQ==,size_16,color_FFFFFF,t_70}  

# 

### wait()、notify()、notifyAll()、join()、sleep()、yield()        
wait() 一般是执行某个功能时候，有条件不满足，既然不满足就让线程进入等待状态。  
notify() 唤醒某个线程 通过这个方式被唤醒的线程是随机的，由系统决定，看谁运气好被CPU选中  
notifyAll() 唤醒等待区的所有线程。   

* 为什么 wait()和notify()必须使用synchronized？    
如果不用就会报错IllegalMonitorStateException,常见写法如下     
```java
synchronized(object){
  object.wait();
}
synchronized(this){
  this.wait();
}
synchronized fun(){
  this.wait();
}
```
首先 wait()和notify()的实现基础是基于对象存在的，那为什么要基于对象存在呢?  
解释: 既然要等，就要考虑等什么，这里的等待的就是一个对象发出的信号，所以要基于对象而存在。  

那为什么必须要使用synchronized呢，或者与对象扯上关系，为什么非要用锁呢?  
暂时保存？  

* (线程合并)join是什么？   
一般一个大而复杂的任务会拆分成几个小任务去执行，最后把每个任务各自的执行的结果汇总输出。但每个任务在单独线程执行这样就有了执行顺序不一致，那怎么样才能在最后把每个线程的执行结果汇总输出呢？  
这时就用到了join，如果在当前线程调用其他线程对象的join方法，那么当前线程就会处于WAIT状态，直到join的线程执行完毕，它才会继续往下执行。

* sleep会导致线程怎么样？    
调用线程的sleep(long)会让线程进入"沉睡"状态,这时线程就啥也不干了。只有到点后线程才能"苏醒"。 如果是线程获得锁后在synchronize内部调用的sleep()方法，这样线程不会释放锁，即使线程在睡觉。  

* yield呢？  
yield是让步，当前正在做的某件事件比较耗时的时候，调用yeild()方法会让线程把CPU资源让出来给其他线程机会。

* interrupt()对什么有用?  
1. interrupt()只对WAI或TIME_WAIT状态有效 会让它们产生实质性的异常抛出。  
2. 对于BLOCKED状态是无法被打断的。    
3. 对一个已经在RUNNABLE状态的线程调用interrupt()方法也没用。处于一个正常执行的代码是不会让它中断的，如果中断成立，那么会使得正常的业务运行出现问题。    

* BLOCKED状态和WAIT状态都是等待，那这两种状态有什么区别呢?
1. BLOCKED 是虚拟机认为程序还不能进入某个区域，因为同时进入就会有问题，这是一块临界区。发生wait()操作的先决条件是要进入临界区，也就是线程已经拿到了"门票"。自己可能进去做一些事情。  
但此时通过判定某些业务上的参数(由具体的业务来决定)发现还有一些其他的配合资源没有准备充分，那么自己就等等再做其他的事情。典型的就是生产-消费者模型。  

# 
 
### 生产和消费者模型      
实现一个生产者和消费者模型    


### 同步    
#### 为什么会有同步的问题？   
在一个多线程环境中，有两个线程同时访问同一位置的文件。一个线程读文件，一个线程写文件。当写文件的线程刚写完关闭文件的那一刻，读线程正好要打开文件。这个时候文件是关闭的，打开失败。这样就造成了对统一资源操作时，出现访问异常的情况。  归纳一下 同步出现的背景主要如下   
1. 多线程    
2. 共享资源    
3. 同一时刻访问    

#### 解决同步的核心思想   
既然同步的原因是用为多线程在同一时刻访问同一资源引起的，那是不是可以不用多线程了。这样看确实单线程就没有问题了，但是单线程的情况操作的效率就低了很多。所以解决不能不用多线程 
总结一下： 所谓同步就是要保证多个线程对同一共享资源操作时，不管是何种调度方式，保持有序的步调，最终能表现出正确的结果，归纳如下。
1. 互斥： 互斥的意思是排他，也就是说在同一时刻当且仅有一个线程能访问共享资源，没有被选中的线程只能等着。  
2. 原子性：原子性的意思是某个操作是不可分割的。比如 修改内存中的一个变量的值，一般是`读-修改-存储`。这三步是一个完整的操作，在同步操作中不能被打断，必须一次性完成。   

#### Java同步的方式有哪些?      
####  synchronize  通过在对象上加锁后进入临界区来达到临界区串行访问的目的    
临界区: 所谓临界区就是指访问这个地方最多只能有一个线程在里面(就像一直钢笔可以给多个人用，但是它在一段时间内最多可以被一个人使用)。  

#### 用法:    
1. 在普通方法前加synchronized, 相等于给当前类的对象加上锁标记(锁是当前对象)。与它互斥的情况有以下三种(也就是说相互之间是串行的)   
synchronized public void test(){
  //do somethings
}
* 在该类的所有非静态方法中发生了`synchronized(this)`   //多个对象竞争同一个对象锁时或一个线程访问同步方法 另一个线程访问以this为锁的同步代码块情况
```java
public void test(){
  synchronized(this){
    dosomething
  }
}
```

* 在该类的所有非静态方法前面加上了`synchronized` 关键字   
```java
synchronized void test_a(){
  dosomething
}
```

* 在其他类中得到该对象的引用，并对该对象进行了`synchronized`操作   
```java
Test test  = new Test()
Thread thread =  new Thread(test);
```

2. 静态方法前加synchronized , 锁是当前类的Class对象(类本身也是一种对象),与它互斥的场景如下   
```java
synchronized public static void test(){
  dosomething
}
```
* 代码中任意一个地方发生了synchronize(A.class)  //A是一个类   
* 在该类的所有静态方法前面加了一个`synchronized`关键字   


3. 同步代码块加synchronized 这里锁对象是当前对象   
```java
public void test(){
  synchronized(this){
    dosomething
  }
}
```

//代码区

#### 总结:  
1. 执行(静态)同步方法和非(静态)同步方法相互之间不影响，即A线程执行(静态)同步方法 B线程执行非(静态)同步方法 A线程的同步方法不会阻塞B线程执行。  
2. 如果执行同一个(静态)同步方法，各线程之间是互斥的，即同一个时刻只允许有一个线程能执行临界区代码    
3. 但同一个锁的同步代码块同一时刻只能被一个线程访问 如下
```java
class Test{
  public synchronized void test(){
    print("线程 Thread.currentThread.getName() 执行了 test 方法");
    Thread.sleep(10000);
  }
  public void test_a(){
    synchronized(this){
     print("线程 Thread.currentThread.getName() 执行了 test_a 方法");
    }
  }
Test test = new Test();
Thread thread_a = new Thread(test);
Thread thread_b = new Thread(test);
thread_a.start();
thread_b.start();
}
//输出
线程 thread a 执行了 test 方法
....
线程 thread b 执行了 test_a 方法
```
4. 不同对象在不同线程调用调用同一个同步方法互不干扰，因为各自线程对应的锁不是同一把。  
5. 线程间同时访问同一个锁的多个同步代码的执行顺序不定 原因是线程执行完一个同步方法会释放锁，执行下个同步方法时会重新竞争锁，所以顺序会不一致。  

#### 重入锁
所谓重入是指当一个线程再次请求自己持有对象锁的临界资源时，这种情况属于重入锁，请求将会成功。 如果不能重入就会造成死锁       
```java
public static void main(String[] args) {
    SynchronizedDemo synDemo = new SynchronizedDemo();
    Thread thread1 = new Thread(() -> {
        synDemo.synMethod();
        synDemo.synMethod2();
    });
    Thread thread2 = new Thread(() -> {
        synDemo.synMethod2();
        synDemo.synMethod();
    });
    thread1.start();
    thread2.start();
}
---------------------
//输出：
Thread-0访问了同步方法synMethod
Thread-0结束访问同步方法synMethod
Thread-0访问了同步方法synMethod2
Thread-0结束访问同步方法synMethod2
Thread-1访问了同步方法synMethod2
Thread-1结束访问同步方法synMethod2
Thread-1访问了同步方法synMethod
Thread-1结束访问同步方法synMethod
//分析：对比248行和250行可知，在代码块中继续调用了当前实例对象的另外一个同步方法，再次请求当前实例锁时，将被允许，进而执行方法体代码，这就是重入锁最直接的体现   
```

#### Synchronized与String锁   
隐患: 由于在JVM中具有String常量池缓存的功能，因此相同字面量是同一个锁！！！   
注意: 严重不推荐将String作为锁对象，而应该改用其他非缓存对象
```java

public class SynchronizedDemo {
      public void stringMethod(String lock){
        synchronized (lock){
            while (true){
                System.out.println(Thread.currentThread().getName());
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}

public static void main(String[] args) {
    SynchronizedDemo synDemo = new SynchronizedDemo();
    Thread thread1 = new Thread(() -> synDemo.stringMethod("sally"));
    Thread thread2 = new Thread(() -> synDemo.stringMethod("sally"));
    thread1.start();
    thread2.start();
}
---------------------
//输出：
Thread-0
Thread-0
Thread-0
Thread-0
...死循环...
//分析：输出结果永远都是Thread-0的死循环，也就是说另一个线程，即Thread-1线程根本不会运行
//原因：同步块中的锁是同一个字面量
```

#### Synchronized与不可变锁Synchronized与不可变锁   
隐患：当使用不可变类对象(final Class)作为对象锁时，使用synchronized同样会有并发问题原因：由于不可变特性，当作为锁但同步块内部仍然有计算操作，会生成一个新的锁对象注意：严重不推荐将final Class作为锁对象时仍对其有计算操作补充：虽然String也是final Class，但它的原因却是字面量常量池
```java
public class SynchronizedDemo {
    static Integer i = 0;   //Integer是final Class
    public static void main(String[] args) throws InterruptedException {
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                for (int j = 0;j<10000;j++){
                    synchronized (i){
                        i++;
                    }
                }
            }
        };
        Thread thread1 = new Thread(runnable);
        Thread thread2 = new Thread(runnable);
        thread1.start();
        thread2.start();
        thread1.join();
        thread2.join();
        System.out.println(i);
    }
}
---------------------
//输出：
14134
//分析：跟预想中的20000不一致，当使用Integer作为对象锁时但还有计算操作就会出现并发问题
```

#### Synchronized与死锁   
`死锁`：当线程间需要相互等待对方已持有的锁时，就形成死锁，进而产生死循环   
```java
public static void main(String[] args) {
    Object lock = new Object();
    Object lock2 = new Object();
    Thread thread1 = new Thread(() -> {
        synchronized (lock){
            System.out.println(Thread.currentThread().getName() + "获取到lock锁");
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            synchronized (lock2){
                System.out.println(Thread.currentThread().getName() + "获取到lock2锁");
            }
        }
    });
    Thread thread2 = new Thread(() -> {
        synchronized (lock2){
            System.out.println(Thread.currentThread().getName() + "获取到lock2锁");
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            synchronized (lock){
                System.out.println(Thread.currentThread().getName() + "获取到lock锁");
            }
        }
    });
    thread1.start();
    thread2.start();
}
---------------------
//输出：
Thread-1获取到lock2锁
Thread-0获取到lock锁
.....
//分析：线程0获得lock锁，线程1获得lock2锁，但之后由于两个线程还要获取对方已持有的锁，但已持有的锁都不会被双方释放，线程"假死"，无法往下执行，从而形成死循环，即死锁，之后一直在做无用的死循环，严重浪费系统资源
```

* 原理:  

示例代码
```java
package concurrent;
public class SynchronizedDemo {
    public static synchronized void staticMethod() throws InterruptedException {
        System.out.println("静态同步方法开始");
        Thread.sleep(1000);
        System.out.println("静态同步方法结束");
    }
    public synchronized void method() throws InterruptedException {
        System.out.println("实例同步方法开始");
        Thread.sleep(1000);
        System.out.println("实例同步方法结束");
    }
    public synchronized void method2() throws InterruptedException {
        System.out.println("实例同步方法2开始");
        Thread.sleep(3000);
        System.out.println("实例同步方法2结束");
    }
    public static void main(String[] args) {
        final SynchronizedDemo synDemo = new SynchronizedDemo();
        Thread thread1 = new Thread(() -> {
            try {
               synDemo.method();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        Thread thread2 = new Thread(() -> {
            try {
                synDemo.method2();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        thread1.start();
        thread2.start();
    }
}
```
![常量池图]{https://pic2.zhimg.com/80/v2-1b0ae664593d4cdace3a715e38b11e69_hd.jpg}

常量池除了会包含基本类型和字符串及数组的常量值外，还包含以文本形式出现的符号引用：

类和接口的全限定名
字段的名称和描述符
方法和名称和描述符

#### synchronized同步生成的Class文件 
1. 同步方法图示    
![同步方法]{https://pic4.zhimg.com/80/v2-4790fc27954b12628f7920f7cbb85737_hd.jpg}     
同步方法会包含一个ACC_SYNCHCRONIZED标记符  

2. 同步代码块图示
![同步代码块]{https://pic4.zhimg.com/80/v2-020dcb2b4c72abc0541cc37f07ce2893_hd.jpg}     
同步代码块会在代码中插入 monitorenter 和 monitorexist 指令  


### 同步代码块原理  
 #### monitor监视器   
 * 对象之所以是锁的原因是每个对象都有一个monitor(监视器)，在同步代码块中，JVM通过monitorenter和monitorexit指令实现同步锁的获取和释放功能   
 * 当一个线程获取锁时，即通过获取monitor监视器进而等价为获取到锁

1. monitorenter指令
 每一个对象都有一个监视器，当该监视器占用时即锁定状态(或者说获取监视器即获得同步锁)。 线程执行monitorenter命令时即尝试获取监视器的所有权(锁的获取是通过执行monitorenter指令来的)，过程如下
 * 若该监视器进入次数为0，则该线程进入监视器并将进入次数设置为1，此时该线程即为监视器的所有者
 * 若该线程已经占有该监视器并重入， 则进入次数+1
 * 若其他线程已经占有该监视器，则线程会被阻塞直到监视器的进入次数为0，之后线程间会竞争获取该监视器的所有权
 * 只有首先获得锁的线程才能允许继续获取多个锁。

 2. monitorexit指令
 * 执行monitorexit指令将遵循以下步骤：
 * 执行monitorexit指令的线程必须是对象实例所对应的监视器的所有者
 * 指令执行时，线程会先将进入次数-1，若-1之后进入次数变成0，则线程退出监视器(即释放锁)
 * 其他阻塞在该监视器的线程可以重新竞争该监视器的所有权 


2. lock   

# 

### 什么是主线程和子线程      
主线程也是UI线程，当一个应用启动的时候， 进程内部只有一个线程就是主线程。主线程主要做UI展示以及和用户交互。    
子线程是除主线程外的所有线程。子线程主要是处理IO、网络等耗时操作。   
# 

### 线程池     

#### 为什么要使用线程池   
1. 线程重用，避免重复创建线程带来的开销    
2. 方便管理线程    
3. 可以执行一些定时任务    

#### 线程池的创建方式    
利用ThreadPool的方式来创建线程池    

#### 线程池的工作原理       

#### 线程池要关注的点有哪些       
   core thread    
   max thread    
   队列  
   抛弃机制  
   线程工厂  

# 

### Java安全的集合、队列、Map    
ArrayList<E>底层原理  
CopyWriteArrayList<E> 底层原理  

Queue 线程安全Queue有哪些  
Map 底层原理  
ConcurrentHashMap 底层实现  
