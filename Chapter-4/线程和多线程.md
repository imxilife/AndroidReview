#### 目标
1. 什么是线程，创建方式、线程状态  
2. 消费者和生产者模型  
3. 同步和锁  
4. 什么是主线程和子线程  
5. 线程池  
6. Java 线程安全的集合、队列、Map  

#### 计划完成时间 一个月  

### 什么是线程？ 线程的创建方式  
1. 线程是OS进行运算调度的最小单元。线程是被包含在进程内，一个进程内的多个线程共享进程资源。

2. 线程的创建方式  
在Java中 单独创建线程都需要使用类 java.lang.Thread。  
2.1 通过继承自Thread类并覆写run()方法  
2.2 实现一个Runnable接口，并在创建线程的时候讲Runnable接口的实例传入。  
```java
//继承自Thread实现run()方法  
class MyThread extends Thread{
  @Override
  public void run(){
    //do something
  }
}

//实现Runnable接口，并实例化传入线程对象中  
class MyRunnable implement Runnable{
  @Override
  public void run(){
    //do something
  }
}
Thread thread = new Thread(new MyRunnable());  
```
以上只是创建了一个线程，真正让一个线程跑起来，能够被OS调度执行 ，还需要调用 `Thread.start()`方法。 这个方法会调用本地方法JNI 来实现一个真正意义上的线程，或者说只有start()  
成功调用后由OS分配线程资源，才能叫做线程。 而在JVM中分配的Thread对象只是与之对应的外壳。  

* 注: 
1. Runnable和Thread的关系 可以理解为  Runnable是任务， Thread是执行任务的，至于执行什么样的任务，Thread不管，开发者通过实现Runnable接口并根据业务逻辑覆写run()方法  
然后将任务交由Thread执行。这样就解耦了任务和线程。都只需要关注各自的事情。  
2. Thread本身所对应的实例仅是JVM内的一个普通java对象，是一个线程操作的外壳，而不是真正的线程.  

# 

### 线程的几种状态    
1. 对线程的每个操作，都可能会是线程处于不同的工作机制下，在不同的工作机制下某些动作可能会产生不同的影响，而不同的工作机制就是用状态来标志的，同时不同状态之间可以相互转换。

2. Java线程的状态一共有六种。    
 * 什么情况会转换到这个状态？    
 * 在这个状态下会有什么情况？    

#### NEW: 表明 这个线程刚被start()启动，从本质上来讲只是创建了Java外壳，还没有真正的线程来运行   

#### RUNNABLE:  这个状态表明存活着正在征用CPU的线程(有可能这个瞬间并没有被CPU选中，但是它可能正在发送指令等待系统调度)，由于在真正的系统中，并不是开启一个线程后 CPU就只为这一个线程
服务，它必须使用许多调度算法来达到某种平衡，不过这个时候线程依然处于RUNNABLE状态  
这个状态可以由WAIT、TIME_WAIT、BLOCKED通过 notify、notifyAll、获得锁等方式进入该状态。当然处于该状态也会可以执行许多操作进入到其他状态 (参见线程状态图)。
* 注意: 一个线程在Java层面可能是RUNNABLE状态，但这并不代表着这个线程就处于运行中。比如 线程正阻塞在网络等待时，看到的状态依然是RUNNABLE状态，而在底层线程已经被阻塞。     

#### WAIT   
1. 这个状态表明一个线程获得锁后 进入相应的代码执行区，调用了“对象”的wait()方法操作后产生的一种后果。出现这种调用一般是当线程在执行某个动作时由于条件不满足，所以暂时先退出执行区域，    
   等待条件满足再来。最典型的例子通过wait()、notify()或notifyAll()完成消费者-生产者模型，当"消费者"线程 消费过快时，仓库已经没有资源了，这个时候应该让消费者线程暂停执行，只有等到    
   仓库有资源了(`条件满足`)，这时唤醒"沉睡"的消费者线程，再次消费。     
   同样的如果"生产者"线程 生产资源够多，仓库"爆仓"了，这个时候生产者线程也应该停止再生产，等待资源被消耗后 这时再"唤醒"生产者线程，再次继续生产。这里体现是通过制衡方式的协调工作机制。  
   在这种状态下，如果发生了对该线程的interrupt()是有用的，处于该状态的线程内部会抛出一个InterruptedException异常，这个异常应当在run()方法里面再次捕获，使得run()方法正常的执行。  
2. 调用某个对象的wait()方法后，首先线程会让出锁资源，同时线程会"沉睡"，不会被CPU再调度，除非有人"唤醒" (调用对象的notify()或notifyAll()方法)它。  

#### TIME_WAIT    
这个状态和上面类似也是进入了等待状态，不过这个是有时间限制的，一旦超过这个时间，线程会自动被"唤醒" 。Thread.sleep(long),Thread.join(long)都可以使线程进入TIME_WAIT状态。  
* 注意: Thread.sleep(long) 如果是在同步区调用的，那么这个线程在"沉睡"期间不会释放锁，及时它没有运行。所有等待同一把锁执行的线程只能干等着。  

#### BLOCKED  
1. 当多个线程竞争同一把"锁",没有被竞争到的线程就会处于阻塞状态，在这个状态下 线程就相当于"沉睡"了，只有当持有"锁"的线程执行完synchronize区域的代码后，退出归还锁，这样才有机会再次去争夺    
进入临界区的权利。争取到锁后会从BLOCKED状态恢复到RUNNABLE状态，如果在征用"锁"的过程中失败了，那么它又只能回休息室等待去了。  
2. 一旦线程处于BLOCKED状态，线程就项什么都不做一样，在JAVA层面始终无法唤醒它，通过interrupt()方法来唤醒也一样。所以在synchronized时通常要考虑它的粒度问题，更要考虑它是否可能会死锁的问题。  

#### TERMINAED  
线程结束了就处于这样一种状态，换句话说就是run()方法走完了，线程就处于这种状态。    

![线程状态图]{https://img-blog.csdnimg.cn/20181120173640764.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BhbmdlMTk5MQ==,size_16,color_FFFFFF,t_70}  

# 

### wait()、notify()、notifyAll()、join()、sleep()、yield()     
wait() 一般是执行某个功能时候，有条件不满足，既然不满足就让线程进入等待状态。  
notify() 唤醒某个线程 通过这个方式被唤醒的线程是随机的，由系统决定，看谁运气好被CPU选中  
notifyAll() 唤醒等待区的所有线程。   

* 为什么 wait()和notify()必须使用synchronized？    
如果不用就会报错IllegalMonitorStateException,常见写法如下     
```java
synchronized(object){
  object.wait();
}
synchronized(this){
  this.wait();
}
synchronized fun(){
  this.wait();
}
```
首先 wait()和notify()的实现基础是基于对象存在的，那为什么要基于对象存在呢?  
解释: 既然要等，就要考虑等什么，这里的等待的就是一个对象发出的信号，所以要基于对象而存在。  

那为什么必须要使用synchronized呢，或者与对象扯上关系，为什么非要用锁呢?  
暂时保存？  

* (线程合并)join是什么？   
一般一个大而复杂的任务会拆分成几个小任务去执行，最后把每个任务各自的执行的结果汇总输出。但每个任务在单独线程执行这样就有了执行顺序不一致，那怎么样才能在最后把每个线程的执行结果汇总输出呢？  
这时就用到了join，如果在当前线程调用其他线程对象的join方法，那么当前线程就会处于WAIT状态，直到join的线程执行完毕，它才会继续往下执行。

* sleep会导致线程怎么样？    
调用线程的sleep(long)会让线程进入"沉睡"状态,这时线程就啥也不干了。只有到点后线程才能"苏醒"。 如果是线程获得锁后在synchronize内部调用的sleep()方法，这样线程不会释放锁，即使线程在睡觉。  

* yield呢？  
yield是让步，当前正在做的某件事件比较耗时的时候，调用yeild()方法会让线程把CPU资源让出来给其他线程机会。

* interrupt()对什么有用?  
1. interrupt()只对WAI或TIME_WAIT状态有效 会让它们产生实质性的异常抛出。  
2. 对于BLOCKED状态是无法被打断的。    
3. 对一个已经在RUNNABLE状态的线程调用interrupt()方法也没用。处于一个正常执行的代码是不会让它中断的，如果中断成立，那么会使得正常的业务运行出现问题。    

* BLOCKED状态和WAIT状态都是等待，那这两种状态有什么区别呢?
1. BLOCKED 是虚拟机认为程序还不能进入某个区域，因为同时进入就会有问题，这是一块临界区。发生wait()操作的先决条件是要进入临界区，也就是线程已经拿到了"门票"。自己可能进去做一些事情。  
但此时通过判定某些业务上的参数(由具体的业务来决定)发现还有一些其他的配合资源没有准备充分，那么自己就等等再做其他的事情。典型的就是生产-消费者模型。  

# 
 
### 生产和消费者模型    
实现一个生产者和消费者模型  


### 同步  
同步  
同步的背景  
同步的核心思想  
Java同步的方式有哪些  

# 

### 什么是主线程和子线程  

# 

### 线程池  

1、为什么要使用线程池  
2、线程池的创建方式  
3、线程池的工作原理  
4、线程池要关注的点有哪些  
   core thread  
   max thread  
   队列  
   抛弃机制  
   线程工厂  

# 

### Java安全的集合、队列、Map    
ArrayList<E>底层原理  
CopyWriteArrayList<E> 底层原理  

Queue 线程安全Queue有哪些  
Map 底层原理  
ConcurrentHashMap 底层实现  
